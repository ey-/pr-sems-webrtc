#
# $Id$
#

# First start SER sample config script with:
#   database, accounting, authentication, multi-domain support
#   PSTN GW section, named flags, named routes, global-,
#   domain- and user-preferences with AVPs
# Several of these features are only here for demonstration purpose
# what can be achieved with the SER config script language.
#
# If you look for a simpler version with a lot less dependencies
# please refer to the ser-basic.cfg file in your SER distribution.

# To get this config running you need to execute the following commands
# with the new serctl (the capital word are just place holders)
# - ser_ctl domain add DOMAINNAME
# - ser_ctl user add USERNAME@DOMAINNAME -p PASSWORD
# If you want to have PID header for your user
# - ser_attr add uid=UID asserted_id="PID"
# If you want to have gateway support
# - ser_db add attr_types name=gw_ip rich_type=string raw_type=2 description="The gateway IP for the default ser.cfg" default_flags=33
# - ser_attr add global gw_ip=GATEWAY-IP

# ----------- global configuration parameters ------------------------

debug=2         # debug level (cmd line: -dddddddddd)
#memdbg=10 # memory debug log level
#memlog=10 # memory statistics log level
#log_facility=LOG_LOCAL0 # sets the facility used for logging (see syslog(3))

# Uncomment these lines to enter debugging mode 
#fork=no
log_stderror=yes


check_via=no    # (cmd. line: -v)
dns=no          # (cmd. line: -r)
rev_dns=no      # (cmd. line: -R)
#port=5060
children=1
#user=ser
#group=ser
#disable_core=yes #disables core dumping
#open_fd_limit=1024 # sets the open file descriptors limit
#mhomed=yes  # usefull for multihomed hosts, small performance penalty
#disable_tcp=yes 
#tcp_accept_aliases=yes # accepts the tcp alias via option (see NEWS)
#enable_tls=yes

syn_branch=0

# bind address
listen=udp:192.168.164.137:5090
#listen=tcp:172.16.115.1:5090

# ------------------ module loading ----------------------------------

loadpath "modules:modules_k"
#loadpath "/usr/lib/ser/modules:/usr/lib/ser/modules_s"

loadmodule "tm"
loadmodule "sl"
loadmodule "rr"
loadmodule "maxfwd"
loadmodule "xlog"
loadmodule "textops"
loadmodule "usrloc"
loadmodule "registrar"

# ----------------- setting script FLAGS -----------------------------
flags
  FLAG_FAILUREROUTE : 1;  # we are operating from a failure route

avpflags
  dialog_cookie;        # handled by rr module

# ----------------- setting module-specific parameters ---------------

modparam("usrloc", "db_mode",   0)

# -- rr params --
# add value to ;lr param to make some broken UAs happy
#modparam("rr", "enable_full_lr", 1)
#
# limit the length of the AVP cookie to only necessary ones
#modparam("rr", "cookie_filter", "(account)")
#
# you probably do not want that someone can simply read and change
# the AVP cookie in your Routes, thus should really change this
# secret value below
#modparam("rr", "cookie_secret", "MyRRAVPcookiesecret")

# -- tm params --
# uncomment the following line if you want to avoid that each new reply
# restarts the resend timer (see INBOUND route below)
#modparam("tm", "restart_fr_on_each_reply", "0")

#modparam("registrar","default_expires",900)
#modparam("registrar","min_expires",240)
#modparam("registrar","max_expires",120)

# -------------------------  request routing logic -------------------

# main routing logic

route{
	# if you have a PSTN gateway just un-comment the follwoing line and 
	# specify the IP address of it to route calls to it
	#$gw_ip = "1.2.3.4"


	# first do some initial sanity checks
	route(INIT);

	# bypass the rest of the script for CANCELs if possible
	route(CATCH_CANCEL);

	if (uri==myself) {

		if (method=="REGISTER") {
		   	#append_to_reply("Expires: 600\r\n");
			#append_to_reply("Min-Expires: 240\r\n");
			save("location");
			break;
		}

		# native SIP destinations are handled using our USRLOC DB
		if (!lookup("location")) {
			sl_reply("404", "Not Found");
			break;
		}
		append_hf("P-hint: usrloc applied\r\n");
	}

	# check if the request is routed via Route header or
	# needs a Record-Route header
	route(RR);

	# forward directly 
	route(FORWARD);
}

route[FORWARD]
{
	# use stateful forwarding as it works reliably
	# even for UDP2TCP
	if (!t_relay()) {
		sl_reply_error();
	}
	drop;
}

route[INIT]
{
	# initial sanity checks -- messages with
	# max_forwards==0, or excessively long requests
	if (!mf_process_maxfwd_header("10")) {
		sl_reply("483","Too Many Hops");
		drop;
	}

	if (msg:len >=  8192 ) {
		sl_reply("513", "Message too big");
		drop;
	}

	# you could add some NAT detection here for example

	# or you cuold call here some of the check from the sanity module

	# lets account all initial INVITEs
	# further in-dialog requests are accounted by a RR cookie (see below)
	#if (method=="INVITE" && strempty(@to.tag)) {
	#	setflag(FLAG_ACC);
	#}
}

route[RR]
{
	# subsequent messages withing a dialog should take the
	# path determined by record-routing
	if (loose_route()) {
		# mark routing logic in request
		append_hf("P-hint: rr-enforced\r\n"); 

		# for broken devices which overwrite their Route's with each
		# (not present) RR from within dialog requests it is better
		# to repeat the RRing
		# and if we call rr after loose_route the AVP cookies are restored
		# automatically :)
		record_route();

		route(FORWARD);
	} else if (!method=="REGISTER") {
		# we record-route all messages -- to make sure that
		# subsequent messages will go through our proxy; that's
		# particularly good if upstream and downstream entities
		# use different transport protocol

		record_route();
	}
}

route[CATCH_CANCEL] {
	# check whether there is a corresponding INVITE to the CANCEL,
	# and bypass the rest of the script if possible

	if (method == CANCEL) {
		if (!t_relay_cancel()) { # implicit drop if the INVITE was found

			# INVITE was found but some error occurred
			sl_reply("500", "Internal Server Error");
			drop;
		}
		# bad luck, no corresponding INVITE was found,
		# we have to continue with the script
	}
}
